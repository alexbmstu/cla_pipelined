<style>

/* By default, make all images center-aligned, and 60% of the width
of the screen in size */
img
{
    display:block;
    float:none;
    margin-left:auto;
    margin-right:auto;
    width:90%;
}

/* Create a CSS class to style images to 90% */
.fullPic
{
    display:block;
    float:none;
    margin-left:auto;
    margin-right:auto;
    width:100%;
}

/* Create a CSS class to style images to 60% */
.normalPic
{
    display:block;
    float:none;
    margin-left:auto;
    margin-right:auto;
    width:60%;
}

/* Create a CSS class to style images to 40% */
.thinPic
{
    display:block;
    float:none;
    margin-left:auto;
    margin-right:auto;
    width:40%;
}

/* Create a CSS class to style images to 20% */
.smallPic
{
    display:inline-block;
    float:left;
    margin-left:none;
    margin-right:none;
    width:150px;
}

/* Create a CSS class to style images to left-align, or "float left" */
.leftAlign
{
    display:inline-block;
    float:left;
    /* provide a 15 pixel gap between the image and the text to its right */
    margin-right:15px;
}

/* Create a CSS class to style images to right-align, or "float right" */
.rightAlign
{
    display:inline-block;
    float:right;
    /* provide a 15 pixel gap between the image and the text to its left */
    margin-left:15px;
}
.image-caption {
  text-align: center;
  font-size: 1.0rem;
}

</style>

## 1. Теоретические основы

### 1.1. Архитектура многоразрядных сумматоров

Многоразрядный сумматор является основным операционным устройством ЭВМ, и от скорости его работы зависит как скорость работы устройств умножения, деления, так и микропроцессора в целом. 

Существует множество архитектур многоразрядных сумматоров, каждая из которых имеет свои преимущества и недостатки в плане скорости, сложности и потребления ресурсов.  Вот некоторые из наиболее распространенных:

**1. Многоразрядный сумматор с последовательным переносом (Ripple-Carry Adder, RCA):**

Сложение в сумматоре с последовательным переносом выполняется побитно,  и  перенос  (carry)  "распространяется"  (ripple)  от  младшего  разряда  к  старшему. Данный вид сумматора обладает наименьшей аппаратной сложностью и количеством сигналов в схеме. Преимуществами такой схемы является простая реализация и минимальное количество логических элементов.
Однако, длительность распространения сигнала переноса от младшего разряда к старшему высока, что приводит к замедлению работы сумматора RCA. Время задержки линейно зависит от количества разрядов. Таким образом, данный вид сумматора плохо подходит для высокоскоростных применений.

**2. Сумматор с передачей переноса по цепочке замкнутых ключей (сквозной перенос, упреждающий перенос, Carry-Lookahead Adder, CLA):**

В данном типе сумматоров для всех разрядов a<sub>i</sub> и b<sub>i</sub> опредяется функция передачи переноса, которая формируется как D<sub>i</sub> = a<sub>i</sub> xor b<sub>i</sub>. При D<sub>i</sub> = 1 (случай a<sub>i</sub>=0 и b<sub>i</sub>=1 или a<sub>i</sub>=1 и b<sub>i</sub>=0) выходной перенос будет равен входному, и цепь c<sub>i-1</sub> замыкается с выходным переносом c<sub>i</sub>. Если же D<sub>i</sub> = 0 (случай a<sub>i</sub>=0 и b<sub>i</sub>=0 или a<sub>i</sub>=1 и b<sub>i</sub>=1) выходной перенос определяется по значению функции a<sub>i</sub> and b<sub>i</sub>, т.е. не зависит от переноса c<sub>i-1</sub>. Это позволяет выполнить коммутацию цепей распространения переноса одновременно для всех разрядов чисел, после чего происходит быстрое распространение сигнала по данным линиям. При этом удается избежать последовательного распространения переноса через логические элементы. Схема CLA сумматора показана на рисунке 1.


<img src="assets/Carry-Lookahead-Adder.png" alt="Сумматор с передачей переноса по цепочке замкнутых ключей(сквозной,  упреждающий перенос, Carry-Lookahead Adder, CLA)" style="width:600px;"/>

{:.image-caption}
**Рисунок 1 — Сумматор с передачей переноса по цепочке замкнутых ключей(сквозной, упреждающий перенос, Carry-Lookahead Adder, CLA)**

Преимуществом сумматора со сквозным переносом по сравнению RCA является меньшая задержка распространения. Для CLA достаточно просто организовать группы разрядов, объединенные в единую цепь распространения переноса, а соединение групп на верхнем иерархическом уровне делает структуру древовидной. В связи с этим CLA значительно быстрее, чем RCA, и задержка логарифмически зависит от количества разрядов (при древовидной схеме наращивания размерности).
Недостатком CLA является более сложная аппаратная реализация, требующая большего количества логических элементов, чем RCA.

Для CLA применяю следующие модификации, существенно повышающие скорость его работы:

* **Параллельная работа CLA:**  В таком сумматоре разряды разбиваются на группы, обрабатываемые на нескольких меньших  CLA  параллельно.
* **Иерархическое наращивание CLA:**  Многоуровневая  иерархия  CLA позволяет построить древовидные схемы для формирования сигналов переноса и сумм. Такие сумматоры позволяют увеличить скорость  сложения и сокращает длину комбинационной цепи до log<sup>b</sup>n (где b-количество параллеьно работающих групп сумматоров).
* **Конвейеризация CLA:**  Несмотря на то, что распространение переноса в CLA быстрее чем в сумматорах с последовательным переносом, для многоразрядных сумматоров (128 разрядов и выше) может потребоваться более одного такта на сложение чисел. В этом случае целесообразно использовтаь принцип конвейеризации для разделения процесса суммирования на несколько стадий. Такая модификаци предоставляют компромисс между сложностью и производительностью.

**3. Сумматор с сохранением переноса (Carry-Save Adder, CSA):**

Вместо того, чтобы складывать числа непосредственно, сумматор с сохранением переноса  CSA генерирует сумму и перенос параллельно.  Эти  результаты  затем  складываются  в  другом  сумматоре (обычно  RCA  или  CLA).  Часто  используется  в  цепочках  для  сложения  трех и более   чисел.
Преимуществов такой схемы является высокая скорость сложения, особенно  хорошо проявляемая при  сложении  более  двух  чисел.
Однако, это требует  дополнительного  сумматора  для  сложения  частичной суммы  и  переноса.

В  высокопроизводительных  системах  часто  используются  комбинации  различных  архитектур  для  оптимизации  работы.  Например,  CSA  может  использоваться  для  предварительного  сложения  нескольких  чисел,  а  затем  результат  складывается  с  помощью  CLA.
 
В ПЛИС часто используется модификация сумматора с с передачей переноса по цепочке замкнутых ключей (CLA), оптимизированная для эффективной реализации на логических элементах ПЛИС.  

Производители ПЛИС (например, Xilinx, Intel/Altera)  предоставляют  специализированные  блоки  (carry chains,  fast  carry  logic)  или  макросы  для  быстрого  сложения.  Эти  блоки  оптимизированы  для  быстрого распространения  переноса  и  эффективно  используют  внутреннюю  архитектуру  ПЛИС.

Для реализации операций сложения или многоразрядных конъюнкций или дизъюнкций в ПЛИС Xilinx применяется схема передачи переноса по цепочке замкнутых ключей, описанная ранее. Такая схема в виде компонента CARRY4 показана на рисунке 2.

<img src="assets/carry4.png" alt="Структура блока CARRY4" style="width:400px;"/>

{:.image-caption}
**Рисунок 2 — Структура блока CARRY4**

 В этом случае логика  упреждающего  переноса  реализована  на  более  низком  уровне  (внутри  блоков  ПЛИС),  что  позволяет  достичь  более  высокой  скорости  по  сравнению  с  реализацией  на  стандартных  логических  элементах и программируемых точках связи. Полная схема конфигурируемого логического блока SLICEM представлена на рисунке 3.

<img src="assets/slicem.png" alt="Структура конфигурируемого логического блока SLICEM" style="width:600px;"/>

{:.image-caption}
**Рисунок 3 — Структура конфигурируемого логического блока SLICEM**


В данной лабораторной работе будут исследованы CLA сумматоры с передачей переноса по цепочке замкнутых ключей, реализованные на ПЛИС Xilinx Virtex 6. 


### 1.2. Статический временной анализ

Статический временной анализ (STA) на ПЛИС — это критически важный этап проектирования, обеспечивающий проверку соответствия временных характеристик проекта заданным требованиям. 

В ходе STA анализируется множество временных параметров, которые можно сгруппировать следующим образом:

1. Задержки распространения сигнала:

      * Комбинационная задержка: Время, необходимое сигналу для прохождения через комбинационную логику (вентили, сумматоры, мультиплексоры и т.д.). Эта задержка зависит от сложности логики, типа вентилей и используемых компонентов ПЛИС.
      * Задержка межсоединений: Время распространения сигнала по проводникам внутри ПЛИС. Зависит от длины проводника, его физических характеристик и параметров маршрутизации.
      * Задержка регистров: Время, необходимое для записи данных в регистр и их считывания (время установки и удержания).
      * Задержка блоков памяти: Время доступа к данным в блоках памяти, встроенных в ПЛИС (RAM, ROM).
      * Задержка специализированных блоков: Задержки, вносимые DSP-блоками, блоками умножения-накопления и другими специализированными блоками ПЛИС.

2. Временные ограничения (constraints). Временные ограничения, это заданные пользователем параметры, определяющие допустимые временные характеристики проекта. К ним относятся:

      * Тактовая частота: Требуемая частота тактового сигнала.
      * Задержки на блоках вводах/вывода: Максимально допустимые задержки на входных и выходных выводах ПЛИС (Pad to Setup, Setup to Pad).
      Временные ограничения между регистрами: Максимально допустимые задержки между регистрами (Register to Register).
      * Ограничения на установку (setup) и удержание (hold): Минимальное время, необходимое для установки входного сигнала перед фронтом тактового сигнала (setup) и минимальное время, которое входной сигнал должен оставаться стабильным после фронта тактового сигнала (hold).
  
Параметры, выявляемые в результате STA:

* **Критический путь.** Наиболее важный параметр проекта, выявляемый в процессе статического временного анализы, это самый длинный путь прохождения сигнала через комбинационную логику. Этот параметр в итоге определяюет максимальную тактовую частоту системы.
* **Слэк (slack).** Разница между требуемым временем и фактическим временем прохождения сигнала по критическому пути. Положительное значение данного параметра указывает на то, что проект соответствует временным требованиям. Отрицательное значение свидетельствует о нарушении временных ограничений.
* **Задержки, связанные с элементами ПЛИС (Switching).** Задержки, вносимые специализированными блоками ПЛИС, такими как память, блоки ввода-вывода, DSP-блоки, блоки умножения-накопления, и т.д. Эти задержки могут значительно отличаться в зависимости от конкретного блока и его конфигурации.
* **Нарушения заданных разработчиком временных ограничений (timing violations).** Ситуации, когда фактическое время прохождения сигнала превышает допустимое время, заданное разработчиком в свойствах проекта. Это может быть связано с нарушением условий setup или hold.

При статическом анализе  `WNS` (Worst Negative Slack), `TNS` (Total Negative Slack), `WHS` (Worst Hold Slack) и `THS` (Total Hold Slack) являются важными метриками, отражающими степень соответствия проекта временным требованиям. 
Значения `WNS` и `TNS` относятся к условию *установки* сигнала (setup),  то есть к тому, насколько быстро сигнал должен установиться *до* фронта тактового сигнала.  `WHS` и `THS`  относятся к условию *удержания* (hold),  то есть к тому, как долго сигнал должен оставаться стабильным *после* фронта тактового сигнала.  Оба условия — setup и hold —  критичны для корректной работы синхронных цифровых систем.

* **`WNS` (Worst Negative Slack).**  Это наихудшая отрицательная временная разница во всём проекте.  Другими словами, это максимальное время, на которое фактическое время прохождения сигнала превышает допустимое время (наибольшее нарушение временных ограничений).  Если `WNS` отрицателен, это означает, что в проекте существуют нарушения временных ограничений, и система может работать некорректно.  Значение `WNS`  указывает на самую критическую проблему со временем в проекте – именно её нужно решать в первую очередь.  Чем больше по модулю отрицательное значение `WNS`, тем серьёзнее нарушение.  Нулевое или положительное значение `WNS` указывает на то, что временные ограничения соблюдены.

* **`TNS` (Total Negative Slack).** Это суммарная отрицательная временная разница по всем нарушениям временных ограничений в проекте.  В отличие от `WNS`, который указывает на самое критическое нарушение, `TNS` даёт общее представление о масштабе проблемы.  Большое значение `TNS` указывает на множество мелких нарушений, даже если `WNS` не очень велико.  Это может свидетельствовать о необходимости более глобальной оптимизации проекта,  а не только устранении самого критического нарушения.   Нулевое или положительное значение `TNS`  означает отсутствие нарушений временных ограничений.

* **`WHS` (Worst Hold Slack).** Это наихудшая отрицательная временная разница, связанная с условием удержания hold.  Условие удержания требует, чтобы входной сигнал оставался стабильным в течение определенного минимального времени *после* фронта тактового сигнала.  Отрицательное значение `WHS` указывает на нарушение условия удержания,  что может привести к непредсказуемому поведению триггеров и системы.  Как и `WNS`,  `WHS` указывает на самое критическое нарушение условия удержания.

* **`THS` (Total Hold Slack).** Это суммарная отрицательная временная разница по всем нарушениям условия удержания. Аналогично `TNS`, `THS`  дает общее представление о масштабе проблем с удержанием сигнала.  Даже если `WHS` не очень велико, большое значение `THS` может указывать на необходимость оптимизации проекта для улучшения соблюдения условий работы триггеров.

Инструменты STA выводят значения `WNS`, `TNS`, `WHS` и `THS` в своих отчётах.  Проектировщики должны следить за тем, чтобы  эти метрики были положительными,  что гарантирует  соблюдение условий удержания.  Нарушение условий удержания может быть столь же критично, как и нарушение условий установки.  Оптимизация проекта может включать в себя  изменение временных ограничений,  добавление буферов или изменение структуры логики.



### 1.3. Конвейеризация цифровых устройств

Конвейеризация (Pipelining) в цифровых устройствах — это метод повышения производительности, при котором сложная операция разбивается на более мелкие подзадачи (этапы, ступени), выполняемые параллельно на специализированных блоках.  Каждый этап выполняет свою часть операции, передавая результат следующему этапу. 

Для конвейерных устройств ключевыми показателями рпоизводительности являются их латентность и пропускная способность. **Латентность (Latency):** – это время, которое проходит от момента подачи входных данных на входную ступень конвейерного устройства до момента появления первого результата на выходе последней ступени. В конвейерных устройствах латентность обычно равна количеству этапов в конвейере. **Пропускная способность (Throughput):** – это количество результатов, выдаваемых конвейерным устройством за единицу времени (количество результатов в секунду или количество результатов за такт).  Это мера характеризует эффективность конвейерного устройств при обработке данных.


**Влияние конвейеризации на производительность.** Конвейеризация увеличивает латентность, так как данные проходят через несколько этапов. При этом также увеличивается пропускная способность. Например, если конвейер содержит `s` стадий, то латентность будет равна `s` тактам.  Это означает, что первый результат появится только после `s` тактов после подачи входных данных. После того, как первый результат был сформирован на выходе, конвейер выдает новые результаты каждый такт. В таком случае говорят, что латентность равна `s`, а пропускная способность равна 1.

**Взаимосвязь латентности и пропускной способности:** Эти два показателя находятся в обратной зависимости.  Увеличение количества этапов в конвейере увеличивает латентность, но при этом увеличивает пропускную способность.  Выбор оптимального числа этапов является компромиссом между этими двумя параметрами, зависящим от конкретных требований приложения.

Снижение латентности важно в тех случаях, где требуется быстрое получение первого результата. Если для системы важным требованием является время отклика, то  конвейеризация  может  быть  не  оптимальным  решением,  несмотря  на  преимущества  в  пропускной  способности. 
С другой стороны, пропускная способность  критична  в  приложениях,  где  требуется  обрабатывать большое  количество  данных.  Если  важно  обработать  максимальное  количество  данных  за  определённое  время,  то  конвейеризация является обоснованным методом.


**Пример: Конвейерный сумматор**

Рассмотрим  128-битный  сумматор.  Без конвейеризации, сложение двух 128-битных чисел происходит за один такт. Однако, такая схема содерит длинные комбинационные цепи, что не позволяет добиться высоких тактовых частот для такого устройства. Если же остальные части проекта способны работать на больших тактовых частотах, то проект оказывается недостаточно оптимизированным. 
В этом случае целесообразно использовать конвейеризацию, разбив сложение на два этапа (по 64 бита на этап), то каждый этап будет выполняться в свой такт.

**Пример сложения чисел без конвейеризации:**
```
|----------------1-й такт--------------|
 [A127:A0] + [B127:B0] = [С127,S127:S0]
```

**Пример сложения чисел с конвейеризации (2 этапа):**

* **Такт 1:**  Сложение бит [A63:A0] и [B63:B0]. На выходе первого этапа сохраняются: результат [S63:S0], старшие разряды чисел [A127:A64] и [B127:B64]  и  перенос  (C63). 
* **Такт 2:**  Сложение бит [A127:A64] и [B127:B64] и переноса C63, результат [S127:S64], и переданные из первого этапа биты [S63:S0] и выходной перенос (C127) запоминаются в регистрах для их чтения принимающим устройством (например, регистрами процессора).

```
|----------------1-й такт-------------|--------------------2-й такт------------------|
  [A63:A0] + [B63:B0] = [С63,S63:S0]      
                                       [A127:A64] + [B127:B64] + С63 = [С127,S127:64]
```

После 2-х тактов результат появляется на выходе сумматора.  Хотя общее время обработки увеличено на один такт,  после этого каждый такт будет выдавать новый результат. Пропускная способность увеличена в 2 раза по сравнению с неконвейерным сумматором.

**Преимущества конвейеризации:**

* **Повышение производительности:** Увеличение пропускной способности (throughput).
* **Увеличение тактовой частоты:** Каждый этап проще,  поэтому можно использовать более высокую тактовую частоту.
* **Уменьшение критической комбинационной цепи:**  Уменьшение максимальной задержки сигнала в длинной комбиционной цепи.


**Недостатки конвейеризации:**

* **Увеличение задержки (latency):**  Время, необходимое для получения первого результата, увеличивается.
* **Увеличение сложности:**  Требуются дополнительные регистры для хранения промежуточных результатов и логики для ожидания результатов.
* **Проблемы синхронизации:**  Необходимо  правильно  синхронизировать  работу  всех  этапов.

Конвейеризация  —  это  эффективный метод  повышения  производительности  цифровых  устройств,  но  его  применение  требует  анализа всего проекта и выбора компромисного варианта с достаточной производительностью,  задержкой  и  сложностью.  Выбор  оптимальной  глубины  конвейеризации  зависит  от  конкретных  требований  проекта.
 
### 1.4. Обобщенная методика разработки конвейерного устройства.


Разработка конвейерного устройства на HDL, это достаточно сложный процесс, требующий применения поэтапного подхода.  Ниже представлено описание методики разработки конвейерного устройства (сумматора, умножителя, устройства для сортировки чисел и т.д.):

**Этап 1. Разработка последовательного устройства и моделирование:**

Сначала необходимо разработать базовое последовательное устройство, которое будет основой для конвейеризации.  Это может быть, например, сумматор, умножитель или любое другое арифметико-логическое устройство.  Последовательное устройство должно быть тщательно смоделировано для проверки его корректной работы.  Результаты моделирования послужат эталоном для проверки работы конвейерной версии.

**Этап 2. Определение количества стадий и настроечной константы:**

Количество стадий конвейера (`s`) определяется исходя из сложности последовательного устройства и требований к производительности.  В Verilog это задаётся с помощью параметра `parameter s = 4;` (например, для 4 стадий).  Это позволяет легко изменять количество стадий без изменения основной логики.

**Этап 3. Определение входных операндов и промежуточных результатов:**

Определите все необходимые входные данные и промежуточные результаты для каждой стадии конвейера.  Например, для сумматора это могут быть два входных операнда и промежуточный результат на каждой стадии.

**Этап 4. Описание сигналов в виде массивов шин:**

Для эффективного представления сигналов между стадиями конвейера целесообразно использовать массивы.  Например:

```Verilog
parameter DATA_WIDTH = 32;
parameter s = 4; // Количество стадий

wire [DATA_WIDTH-1:0] stage_in [s:0];
wire [DATA_WIDTH-1:0] stage_out [s:0];
```

`stage_in` и `stage_out` представляют собой массивы шин, соединяющие стадии.  Избыточные сигналы будут оптимизированы синтезатором.

**Этап 5. Ввод входных операндов в начальную ступень конвейера:**

Если не требуется создавать входные регистры данных (в общем случае входные регистры могут быть вынесены за пределы описания конвейерного устройства), то входные операнды загружаются в массив `stage_in[0]` комбинационным образом. 

Это может быть выполнено, например, с помощью следующей  асинхронной конструкции на языке Verilog:

```Verilog
always @(input_data) begin
  stage_in[0] <= input_data;
end
```
Такой вариант ввода сигналов упрощает описание ступеней конвейера, так как позволяет представить их в виде циклических конструкций.

**Этап 6. Разработка конвейерного варианта устройства с использованием циклов:**

Конвейер можно реализовать с помощью вложенных циклов `generate` для создания s экземпляров последовательного устройства:


```Verilog
genvar i;
generate
  for (i = 0; i < s; i = i + 1) begin : stage
    // Здесь размещается экземпляр последовательного устройства,
    //  подключенный к stage_in[i] и stage_out[i]
  end
endgenerate
```

Или же, используя циклы внутри блока `always` с переменной типа `integer`.  Этот подход может быть более гибким, но требует более аккуратного управления тактовой синхронизацией.  Выбор между `generate` и `always` зависит от сложности последовательного устройства и архитектурных предпочтений.

Упрощенный пример описания `s`-стадийного конвейера внутри блока generate показан ниже: 

```Verilog
genvar i;
generate
  for (i = 0; i < s; i = i + 1) begin : stage
    always @(posedge clk) begin // Тактовая синхронизация внутри стадии
       if (i == 0) begin
          stage_out[i] <= some_operation(stage_in[i]); //Обработка данных на первой стадии
       end else begin
          stage_out[i] <= some_operation(stage_in[i]); //Обработка данных на остальных стадиях
       end
       stage_in[i+1] <= stage_out[i]; //Передача данных на следующую стадию

    end
  end
endgenerate
```


**Этап 7. Моделирование конвейерного устройства и проверка работоспособности при изменении количества стадий**

После реализации конвейера необходимо выполнить его тщательное моделирование, сравнивая результаты с эталонным последовательным устройством.

Изменение значения стадий конвейера `s`, задавае с помощью параметра модуля, автоматически перестраивает конвейер. Это является преимуществом испольования настроечных констант,но повышает трудоемкость разработки исходных описаний. 
Также, это требует дополнительных усилий по проверке работоспособности устройства при изменениипараметров: простое изменение параметра не гарантирует корректной работы при всех значениях `s`.  Необходимо учесть несколько аспектов:

* **Граничные условия.** Проверьте работу при минимальном (`s=1`,  в этом случае конвейер фактически превращается в последовательное устройство) и максимальном (заданном в спецификации) значениях `s`, а также при нескольких промежуточных значениях.  Это позволит выявить потенциальные ошибки, связанные с индексацией массивов или обработкой граничных случаев в циклах.

* **Время выполнения.**  По мере увеличения `s` увеличивается и время прохождения данных через конвейер.  Необходимо убедиться, что время прохождения данных остается в допустимых пределах.

* **Загрузка ресурсов.** Увеличение `s` приводит к увеличению потребления ресурсов FPGA (логические элементы, регистры, маршрутизация).  Необходимо контролировать использование ресурсов и убедиться, что они остаются в допустимых пределах.

* **Синхронизация.**  При изменении `s` необходимо убедиться, что все синхронные процессы остаются синхронизированными.  Возможны проблемы с тактовой синхронизацией и возникновением гонок данных.

* **Тестирование.** Необходимо разработать исчерпывающий набор тестовых векторов, покрывающий различные сценарии работы конвейера при разных значениях `s`.  Эти тесты должны проверять корректность вычислений, а также устойчивость к различным входным данным и условиям.

Для проверки работоспособности при различных значениях `s` может быть использовано сравнение результатов работы конвейера при разных значениях `s` с эталонными данными, полученными, например, с помощью программного моделирования или с помощью  последовательной версии устройства.


**Этап 8. Экспериментальное определение параметров устройства при изменении количества стадий**

Экспериментальное определение параметров устройства при изменении количества стадий конвейера — важный этап, позволяющий оценить влияние архитектурных решений на производительность и потребление ресурсов.  Этот процесс включает в себя  систематическое изменение количества стадий (`s`) и анализ полученных результатов.  

Основныне метрики устройства, которые оцениваются для каждого варианта включают:

* **Тактовая частота.** 
  Тактовая частота определяется после синтеза и статического временного анализа (STA), и в схемно-топологического проектирования. Нужно учесть, что изменения в исходных описаниях и задание различных ограничений (на частоту тактового сигнала), влияет на работу алгоритмов САПР и изменяет результаты синтеза и формирования топологии интегральной схемы. Поэтому целесообразно проводить итерационный экспериментальный процесс опрееделния наилучших параметров устройства при изменении настроечных парамтеров. Получив значение максимальной ю частоту, на которой устройство гарантированно будет работать без ошибок, можно судить о времени распространения сигнала через критические пути в устройстве.

  Идеальный конвейер должен позволять повысить тактовую частоту по сравнению с непоследовательной версией.  Однако, увеличение числа стадий может привести к усложнению критических путей и, как следствие, к снижению тактовой частоты.  График зависимости тактовой частоты от числа стадий поможет определить оптимальное значение, после которого прирост частоты незначителен или вовсе отсутствует.

* **Латентность.** 
  Латентность (время, необходимое для обработки одного набора входных данных) задается разработчиком с структуре устройства и подтверждается результатами моделирования. При едином тактировании конвейера латентность измеряется в тактах, и не требует экспериментального подтверждения. Если же конвейер использует независимую синхронизацию каждой стадии (например, синхросигналами равной частоты и со сдвигами по фазе относительно друг друга), то латентность должна исследоваться более детально. 
  
  Во втором случае, латентность должна быть приблизительно постоянной и равной времени обработки одного этапа в конвейере, умноженному на число стадий (плюс задержки).  Однако, на практике это может быть не так из-за неравномерной загрузки стадий и различных задержек на разных этапах обработки.  График зависимости латентности от числа стадий покажет, как растёт общее время обработки данных при увеличении числа стадий.

* **Аппаратная сложность.** 
  Аппаратная сложность определяется количеством используемых ресурсов FPGA, таких как:
    * Количество логических элементов (LUTs).
    * Количество регистров (FFs).
    * Количество блоков памяти (LUT RAMs, Block RAMs, Ultra RAMs).
    * Количество блоков умножения (DSP48s) 
  Эти показатели предоставляются отчетами синтеза и размещения/маршрутизации. С ростом числа стадий этот показатель, как правило, линейно растёт.  Необходимо найти баланс между увеличением производительности (за счёт увеличения числа стадий) и ростом потребления ресурсов.  Слишком большое число стадий может привести к чрезмерному использованию ресурсов и к невозможности размещения проекта на целевом устройстве.

После получения данных по тактовой частоте, латентности и аппаратной сложности для различных значений `s`, строятся графики зависимости этих показателей.  Анализ графиков позволяет определить оптимальное значение `s`, которое обеспечивает наилучший компромисс между производительностью, латентностью и использованием ресурсов.  Например, можно искать точку, где увеличение производительности за счет увеличения числа стадий незначительно, а потребление ресурсов резко возрастает.  Это указывает на точку оптимального компромисса.
 
Далее выполним этапы методики на примере CLA сумматора со сквозным перенносом. 


